{"message":"The system cannot find the path specified. (os error 3)","code":null,"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2940,"byte_end":2983,"line_start":112,"line_end":112,"column_start":27,"column_end":70,"is_primary":true,"text":[{"text":"        Some(db) => match sqlx_macros::migrate!(\"db/sqlx/migrations\") {","highlight_start":27,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2940,"byte_end":2983,"line_start":112,"line_end":112,"column_start":27,"column_end":70,"is_primary":false,"text":[{"text":"        Some(db) => match sqlx_macros::migrate!(\"db/sqlx/migrations\") {","highlight_start":27,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx_macros::migrate!","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2474,"byte_end":2523,"line_start":86,"line_end":86,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn migrate(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: The system cannot find the path specified. (os error 3)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:112:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Some(db) => match sqlx_macros::migrate!(\"db/sqlx/migrations\") {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `sqlx_macros::migrate` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot find value `email` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1396,"byte_end":1401,"line_start":50,"line_end":50,"column_start":11,"column_end":16,"is_primary":true,"text":[{"text":"    .bind(email)","highlight_start":11,"highlight_end":16}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find value `email` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:50:11\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    .bind(email)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find value `username` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1414,"byte_end":1422,"line_start":51,"line_end":51,"column_start":11,"column_end":19,"is_primary":true,"text":[{"text":"    .bind(username);","highlight_start":11,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find value `username` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:51:11\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    .bind(username);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find value `username` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1560,"byte_end":1568,"line_start":56,"line_end":56,"column_start":11,"column_end":19,"is_primary":true,"text":[{"text":"    .bind(username)","highlight_start":11,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find value `username` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:56:11\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    .bind(username)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find value `title` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1581,"byte_end":1586,"line_start":57,"line_end":57,"column_start":11,"column_end":16,"is_primary":true,"text":[{"text":"    .bind(title);","highlight_start":11,"highlight_end":16}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find value `title` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:57:11\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    .bind(title);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find value `user` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1926,"byte_end":1930,"line_start":71,"line_end":71,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"        .bind(user)","highlight_start":15,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find value `user` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:71:15\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .bind(user)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find value `title` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1947,"byte_end":1952,"line_start":72,"line_end":72,"column_start":15,"column_end":20,"is_primary":true,"text":[{"text":"        .bind(title);","highlight_start":15,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find value `title` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:72:15\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .bind(title);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find value `user` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2269,"byte_end":2273,"line_start":84,"line_end":84,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"        .bind(user)","highlight_start":15,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find value `user` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:84:15\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .bind(user)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find value `title` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2290,"byte_end":2295,"line_start":85,"line_end":85,"column_start":15,"column_end":20,"is_primary":true,"text":[{"text":"        .bind(title);","highlight_start":15,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find value `title` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:85:15\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m85\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .bind(title);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find value `user` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2626,"byte_end":2630,"line_start":99,"line_end":99,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"        .bind(user)","highlight_start":15,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find value `user` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:99:15\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m99\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .bind(user)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find value `title` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2647,"byte_end":2652,"line_start":100,"line_end":100,"column_start":15,"column_end":20,"is_primary":true,"text":[{"text":"        .bind(title);","highlight_start":15,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find value `title` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:100:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m100\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .bind(title);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"unused imports: `Deserialize`, `Serialize`, `futures`, `json::Json`, `response::status::Created`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":48,"byte_end":55,"line_start":3,"line_end":3,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    futures,","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":62,"byte_end":87,"line_start":4,"line_end":4,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"    response::status::Created,","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":102,"byte_end":112,"line_start":5,"line_end":5,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"    serde::{json::Json, Deserialize, Serialize},","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":114,"byte_end":125,"line_start":5,"line_end":5,"column_start":25,"column_end":36,"is_primary":true,"text":[{"text":"    serde::{json::Json, Deserialize, Serialize},","highlight_start":25,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":127,"byte_end":136,"line_start":5,"line_end":5,"column_start":38,"column_end":47,"is_primary":true,"text":[{"text":"    serde::{json::Json, Deserialize, Serialize},","highlight_start":38,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":41,"byte_end":137,"line_start":2,"line_end":5,"column_start":27,"column_end":48,"is_primary":true,"text":[{"text":"    fairing::{self, AdHoc},","highlight_start":27,"highlight_end":28},{"text":"    futures,","highlight_start":1,"highlight_end":13},{"text":"    response::status::Created,","highlight_start":1,"highlight_end":31},{"text":"    serde::{json::Json, Deserialize, Serialize},","highlight_start":1,"highlight_end":48}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused imports: `Deserialize`, `Serialize`, `futures`, `json::Json`, `response::status::Created`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:3:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    futures,\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    response::status::Created,\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    serde::{json::Json, Deserialize, Serialize},\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused import: `Connection`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":192,"byte_end":202,"line_start":8,"line_end":8,"column_start":29,"column_end":39,"is_primary":true,"text":[{"text":"use rocket_db_pools::{sqlx, Connection, Database};","highlight_start":29,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":190,"byte_end":202,"line_start":8,"line_end":8,"column_start":27,"column_end":39,"is_primary":true,"text":[{"text":"use rocket_db_pools::{sqlx, Connection, Database};","highlight_start":27,"highlight_end":39}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `Connection`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:8:29\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse rocket_db_pools::{sqlx, Connection, Database};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^\u001b[0m\n\n"}
{"message":"the trait bound `User: external_sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1478,"byte_end":1483,"line_start":53,"line_end":53,"column_start":51,"column_end":56,"is_primary":true,"text":[{"text":"    let mut videos = external_sqlx::query_as::<_, Video>(","highlight_start":51,"highlight_end":56}],"label":"the trait `external_sqlx::Decode<'_, _>` is not implemented for `User`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Decode<'r, DB>`:\n  <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\n  <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\nand 27 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `User: external_sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:53:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m53\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut videos = external_sqlx::query_as::<_, Video>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Decode<'_, _>` is not implemented for `User`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Decode<'r, DB>`:\u001b[0m\n\u001b[0m              <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\u001b[0m\n\u001b[0m              <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 27 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `User: external_sqlx::Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1478,"byte_end":1483,"line_start":53,"line_end":53,"column_start":51,"column_end":56,"is_primary":true,"text":[{"text":"    let mut videos = external_sqlx::query_as::<_, Video>(","highlight_start":51,"highlight_end":56}],"label":"the trait `external_sqlx::Type<_>` is not implemented for `User`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Type<DB>`:\n  <&T as external_sqlx::Type<DB>>\n  <() as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\nand 28 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `User: external_sqlx::Type<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:53:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m53\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut videos = external_sqlx::query_as::<_, Video>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Type<_>` is not implemented for `User`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Type<DB>`:\u001b[0m\n\u001b[0m              <&T as external_sqlx::Type<DB>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 28 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `Caption: external_sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1478,"byte_end":1483,"line_start":53,"line_end":53,"column_start":51,"column_end":56,"is_primary":true,"text":[{"text":"    let mut videos = external_sqlx::query_as::<_, Video>(","highlight_start":51,"highlight_end":56}],"label":"the trait `external_sqlx::Decode<'_, _>` is not implemented for `Caption`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Decode<'r, DB>`:\n  <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\n  <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\nand 27 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `Caption: external_sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:53:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m53\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut videos = external_sqlx::query_as::<_, Video>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Decode<'_, _>` is not implemented for `Caption`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Decode<'r, DB>`:\u001b[0m\n\u001b[0m              <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\u001b[0m\n\u001b[0m              <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 27 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `Caption: external_sqlx::Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1478,"byte_end":1483,"line_start":53,"line_end":53,"column_start":51,"column_end":56,"is_primary":true,"text":[{"text":"    let mut videos = external_sqlx::query_as::<_, Video>(","highlight_start":51,"highlight_end":56}],"label":"the trait `external_sqlx::Type<_>` is not implemented for `Caption`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Type<DB>`:\n  <&T as external_sqlx::Type<DB>>\n  <() as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\nand 28 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `Caption: external_sqlx::Type<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:53:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m53\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut videos = external_sqlx::query_as::<_, Video>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Type<_>` is not implemented for `Caption`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Type<DB>`:\u001b[0m\n\u001b[0m              <&T as external_sqlx::Type<DB>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 28 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `User: external_sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1888,"byte_end":1893,"line_start":70,"line_end":70,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(insertion_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Decode<'_, _>` is not implemented for `User`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Decode<'r, DB>`:\n  <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\n  <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\nand 27 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `User: external_sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:70:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(insertion_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Decode<'_, _>` is not implemented for `User`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Decode<'r, DB>`:\u001b[0m\n\u001b[0m              <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\u001b[0m\n\u001b[0m              <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 27 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `User: external_sqlx::Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1888,"byte_end":1893,"line_start":70,"line_end":70,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(insertion_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Type<_>` is not implemented for `User`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Type<DB>`:\n  <&T as external_sqlx::Type<DB>>\n  <() as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\nand 28 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `User: external_sqlx::Type<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:70:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(insertion_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Type<_>` is not implemented for `User`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Type<DB>`:\u001b[0m\n\u001b[0m              <&T as external_sqlx::Type<DB>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 28 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `Caption: external_sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1888,"byte_end":1893,"line_start":70,"line_end":70,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(insertion_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Decode<'_, _>` is not implemented for `Caption`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Decode<'r, DB>`:\n  <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\n  <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\nand 27 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `Caption: external_sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:70:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(insertion_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Decode<'_, _>` is not implemented for `Caption`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Decode<'r, DB>`:\u001b[0m\n\u001b[0m              <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\u001b[0m\n\u001b[0m              <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 27 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `Caption: external_sqlx::Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":1888,"byte_end":1893,"line_start":70,"line_end":70,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(insertion_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Type<_>` is not implemented for `Caption`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Type<DB>`:\n  <&T as external_sqlx::Type<DB>>\n  <() as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\nand 28 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `Caption: external_sqlx::Type<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:70:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(insertion_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Type<_>` is not implemented for `Caption`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Type<DB>`:\u001b[0m\n\u001b[0m              <&T as external_sqlx::Type<DB>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 28 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `User: external_sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2234,"byte_end":2239,"line_start":83,"line_end":83,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(update_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Decode<'_, _>` is not implemented for `User`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Decode<'r, DB>`:\n  <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\n  <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\nand 27 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `User: external_sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:83:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m83\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(update_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Decode<'_, _>` is not implemented for `User`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Decode<'r, DB>`:\u001b[0m\n\u001b[0m              <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\u001b[0m\n\u001b[0m              <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 27 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `User: external_sqlx::Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2234,"byte_end":2239,"line_start":83,"line_end":83,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(update_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Type<_>` is not implemented for `User`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Type<DB>`:\n  <&T as external_sqlx::Type<DB>>\n  <() as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\nand 28 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `User: external_sqlx::Type<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:83:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m83\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(update_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Type<_>` is not implemented for `User`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Type<DB>`:\u001b[0m\n\u001b[0m              <&T as external_sqlx::Type<DB>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 28 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `Caption: external_sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2234,"byte_end":2239,"line_start":83,"line_end":83,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(update_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Decode<'_, _>` is not implemented for `Caption`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Decode<'r, DB>`:\n  <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\n  <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\nand 27 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `Caption: external_sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:83:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m83\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(update_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Decode<'_, _>` is not implemented for `Caption`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Decode<'r, DB>`:\u001b[0m\n\u001b[0m              <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\u001b[0m\n\u001b[0m              <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 27 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `Caption: external_sqlx::Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2234,"byte_end":2239,"line_start":83,"line_end":83,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(update_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Type<_>` is not implemented for `Caption`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Type<DB>`:\n  <&T as external_sqlx::Type<DB>>\n  <() as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\nand 28 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `Caption: external_sqlx::Type<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:83:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m83\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(update_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Type<_>` is not implemented for `Caption`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Type<DB>`:\u001b[0m\n\u001b[0m              <&T as external_sqlx::Type<DB>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 28 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `User: external_sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2589,"byte_end":2594,"line_start":98,"line_end":98,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(deletion_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Decode<'_, _>` is not implemented for `User`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Decode<'r, DB>`:\n  <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\n  <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\nand 27 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `User: external_sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:98:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m98\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(deletion_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Decode<'_, _>` is not implemented for `User`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Decode<'r, DB>`:\u001b[0m\n\u001b[0m              <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\u001b[0m\n\u001b[0m              <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 27 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `User: external_sqlx::Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2589,"byte_end":2594,"line_start":98,"line_end":98,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(deletion_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Type<_>` is not implemented for `User`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Type<DB>`:\n  <&T as external_sqlx::Type<DB>>\n  <() as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\nand 28 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `User: external_sqlx::Type<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:98:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m98\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(deletion_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Type<_>` is not implemented for `User`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Type<DB>`:\u001b[0m\n\u001b[0m              <&T as external_sqlx::Type<DB>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 28 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `Caption: external_sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2589,"byte_end":2594,"line_start":98,"line_end":98,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(deletion_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Decode<'_, _>` is not implemented for `Caption`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Decode<'r, DB>`:\n  <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\n  <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\nand 27 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `Caption: external_sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:98:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m98\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(deletion_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Decode<'_, _>` is not implemented for `Caption`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Decode<'r, DB>`:\u001b[0m\n\u001b[0m              <&'r JsonRawValue as external_sqlx::Decode<'r, DB>>\u001b[0m\n\u001b[0m              <&'r [u8] as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <&'r str as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Decode<'r, external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 27 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"the trait bound `Caption: external_sqlx::Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":2589,"byte_end":2594,"line_start":98,"line_end":98,"column_start":49,"column_end":54,"is_primary":true,"text":[{"text":"    let mut rows = external_sqlx::query_as::<_, Video>(deletion_args)","highlight_start":49,"highlight_end":54}],"label":"the trait `external_sqlx::Type<_>` is not implemented for `Caption`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `external_sqlx::Type<DB>`:\n  <&T as external_sqlx::Type<DB>>\n  <() as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\n  <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\nand 28 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\data\\pg_client_interface.rs","byte_start":626,"byte_end":648,"line_start":29,"line_end":29,"column_start":10,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(external_sqlx::FromRow)]","highlight_start":10,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(external_sqlx::FromRow)]","def_site_span":{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-macros-0.6.2\\src\\lib.rs","byte_start":2166,"byte_end":2223,"line_start":75,"line_end":75,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":659,"byte_end":664,"line_start":30,"line_end":30,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"struct Video {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `external_sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs","byte_start":5029,"byte_end":5057,"line_start":174,"line_end":174,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `Caption: external_sqlx::Type<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:98:49\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m98\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut rows = external_sqlx::query_as::<_, Video>(deletion_args)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `external_sqlx::Type<_>` is not implemented for `Caption`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `external_sqlx::Type<DB>`:\u001b[0m\n\u001b[0m              <&T as external_sqlx::Type<DB>>\u001b[0m\n\u001b[0m              <() as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m              <(T1, T2, T3, T4, T5, T6, T7) as external_sqlx::Type<external_sqlx::Postgres>>\u001b[0m\n\u001b[0m            and 28 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `Video` to implement `for<'r> external_sqlx::FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:29:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(external_sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m30\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Video {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `external_sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\danie\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\sqlx-core-0.6.2\\src\\query_as.rs:174:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the derive macro `external_sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0284","explanation":"This error occurs when the compiler is unable to unambiguously infer the\nreturn type of a function or method which is generic on return type, such\nas the `collect` method for `Iterator`s.\n\nFor example:\n\n```compile_fail,E0284\nfn main() {\n    let n: u32 = 1;\n    let mut d: u64 = 2;\n    d = d + n.into();\n}\n```\n\nHere we have an addition of `d` and `n.into()`. Hence, `n.into()` can return\nany type `T` where `u64: Add<T>`. On the other hand, the `into` method can\nreturn any type where `u32: Into<T>`.\n\nThe author of this code probably wants `into()` to return a `u64`, but the\ncompiler can't be sure that there isn't another type `T` where both\n`u32: Into<T>` and `u64: Add<T>`.\n\nTo resolve this error, use a concrete type for the intermediate expression:\n\n```\nfn main() {\n    let n: u32 = 1;\n    let mut d: u64 = 2;\n    let m: u64 = n.into();\n    d = d + m;\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":3340,"byte_end":3354,"line_start":127,"line_end":127,"column_start":21,"column_end":35,"is_primary":false,"text":[{"text":"            .attach(Database::init())","highlight_start":21,"highlight_end":35}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\data\\pg_client_interface.rs","byte_start":3333,"byte_end":3339,"line_start":127,"line_end":127,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"            .attach(Database::init())","highlight_start":14,"highlight_end":20}],"label":"cannot infer type of the type parameter `F` declared on the associated function `attach`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"cannot satisfy `<_ as rocket_db_pools::Database>::Pool == _`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider specifying the generic argument","code":null,"level":"help","spans":[{"file_name":"src\\data\\pg_client_interface.rs","byte_start":3339,"byte_end":3339,"line_start":127,"line_end":127,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"            .attach(Database::init())","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"::<Initializer<Self>>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0284]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\data\\pg_client_interface.rs:127:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m127\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .attach(Database::init())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mtype must be known at this point\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type of the type parameter `F` declared on the associated function `attach`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: cannot satisfy `<_ as rocket_db_pools::Database>::Pool == _`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider specifying the generic argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m127\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            .attach\u001b[0m\u001b[0m\u001b[38;5;10m::<Initializer<Self>>\u001b[0m\u001b[0m(Database::init())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\n\n"}
{"message":"aborting due to 28 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 28 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0277, E0284, E0425.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0277, E0284, E0425.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
